<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Omni Logic - V21</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        html, body { background-color: #010816; color: white; height: 100%; overflow-y: auto; font-family: 'Inter', sans-serif; -webkit-tap-highlight-color: transparent; }
        .box-p { border: 4px solid #ff4136; color: #ff4136; border-radius: 50%; width: 55px; height: 55px; font-size: 24px; display: flex; align-items: center; justify-content: center; margin: 0 auto; background: white; font-weight: 900; }
        .box-e { border: 4px solid #b10dc9; color: #b10dc9; border-radius: 12px; width: 55px; height: 55px; font-size: 24px; display: flex; align-items: center; justify-content: center; margin: 0 auto; background: white; font-weight: 900; }
        .box-s { border: 4px solid #2ecc40; color: #2ecc40; border-radius: 8px; width: 50px; height: 50px; font-size: 24px; display: flex; align-items: center; justify-content: center; margin: 0 auto; transform: rotate(45deg); background: white; font-weight: 900; }
        .box-s span { transform: rotate(-45deg); display: block; }
        .log-box { padding: 12px; margin-bottom: 10px; border-radius: 16px; border-left: 8px solid rgba(0,0,0,0.3); color: white; }
        .bg-big { background: linear-gradient(to right, #ff4136, #85144b); } 
        .bg-small { background: linear-gradient(to right, #2ecc40, #3d9970); } 
        .bg-jump { background: linear-gradient(to right, #b10dc9, #0074d9); } 
        .bg-double { background: linear-gradient(to right, #ffdc00, #ff851b); color: black; }
        .g-num { background: #ffdc00; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 50%; border: 2px solid #000; color: black; font-weight: 900; font-size: 14px; }
        .mini-shape { width: 24px; height: 24px; display: inline-flex; align-items: center; justify-content: center; background: white; font-weight: 900; font-size: 11px; border-width: 2px; }
        #toast { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: #2ecc40; color: white; padding: 10px 20px; border-radius: 12px; font-weight: bold; display: none; z-index: 9999; }
        #streak-warning { 
            transition: all 0.3s ease-in-out;
            opacity: 1;
            max-height: 100px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        #streak-warning.hidden {
            opacity: 0;
            max-height: 0;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
</head>
<body class="p-2 pb-10">
    <div id="toast">HISTORY COPIED!</div>
    <div id="app-main" class="max-w-md mx-auto space-y-4">
        <div class="text-center pt-2">
            <h1 class="text-2xl font-black italic text-cyan-500 uppercase">Omni Logic V21</h1>
            <div class="text-[9px] text-cyan-400 font-bold uppercase mt-1 italic">Precise Warning Auto-Hide</div>
        </div>

        <!-- WARNING BOX -->
        <div id="streak-warning" class="hidden">
            <div id="warning-box" class="p-4 rounded-2xl text-center border-l-8 shadow-2xl mx-2">
                <p id="warning-text" class="font-black text-[14px] uppercase text-white italic"></p>
            </div>
        </div>

        <div class="bg-[#001d3d] p-4 grid grid-cols-3 gap-1 text-center rounded-[2rem] border-b-4 border-cyan-500 shadow-lg">
            <div><p class="text-[9px] text-gray-500 mb-1 font-black uppercase">P-Logic</p><div class="box-p"><span id="pred-p">-</span></div></div>
            <div><p class="text-[9px] text-gray-500 mb-1 font-black uppercase">E-Logic</p><div class="box-e"><span id="pred-e">-</span></div></div>
            <div><p class="text-[9px] text-gray-500 mb-1 font-black uppercase">S-Logic</p><div class="box-s"><span id="pred-s"></span></div></div>
        </div>

        <div class="bg-[#001d3d] p-5 rounded-[2.5rem] flex items-center justify-between border border-white/5 gap-3 shadow-2xl">
            <div class="text-6xl font-black text-cyan-400 flex-1 text-center" id="highlight-g">-</div>
            <div class="flex flex-col gap-2 w-32">
                <input type="tel" id="digit-input" maxlength="1" oninput="this.value=this.value.replace(/[^0-9]/g,'');" class="w-full rounded-xl text-center text-4xl font-black p-2 border-4 border-cyan-500 text-black outline-none bg-white" placeholder="0">
                <button class="w-full py-3 bg-cyan-500 text-white font-black rounded-xl active:scale-95 shadow-lg" id="btn-enter" onclick="handleManualSubmit()">ENTER</button>
            </div>
        </div>

        <button onclick="copyAnalysis()" class="w-full py-4 bg-white/10 border-2 border-white/20 rounded-2xl text-white text-[10px] font-black uppercase tracking-widest shadow-lg active:bg-cyan-500">üìã Copy History</button>

        <div id="history-container" class="flex overflow-x-auto gap-3 py-1"></div>

        <div class="px-2">
            <h3 class="text-yellow-500 text-[10px] font-black uppercase tracking-wider mb-2 italic">Pattern Intelligence (PIH)</h3>
            <div id="intel-wrapper" class="bg-white/5 rounded-[2.5rem] p-5 border border-white/5">
                <div id="intel-log-container" class="h-[280px] overflow-y-auto"><p id="no-intel" class="text-center text-gray-700 text-[10px] mt-24 italic font-bold">READY...</p></div>
            </div>
        </div>

        <div class="px-2 pt-4 pb-12"><button onclick="fullReset()" class="w-full py-4 bg-gradient-to-r from-red-600 to-red-900 text-white font-black rounded-2xl shadow-xl uppercase text-[10px]">Reset All Data</button></div>
    </div>

    <script>
        let history = []; 
        let intelLogs = [];
        let roll = 1, stage = 1, pNext = "-", eNext = "-", sNext = "-";
        let activePattern = null;

        const inputEl = document.getElementById('digit-input');
        inputEl.addEventListener('keydown', (e) => { 
            if (e.key === 'Enter') handleManualSubmit(); 
        });

        function handleManualSubmit() {
            const valStr = inputEl.value.trim();
            if (valStr === "") return;
            const num = parseInt(valStr);
            const grp = num >= 5 ? 'B' : 'S';
            
            inputEl.value = "";
            document.getElementById('highlight-g').innerText = num;
            
            setTimeout(() => {
                processGame(num, grp);
                inputEl.focus();
            }, 10);
        }

        function processGame(num, grp) {
            // Detect pattern BEFORE adding to history
            detectAndRecord(grp);
            
            history.push({ 
                val: num, 
                grp, 
                roll, 
                stage, 
                p: pNext, 
                pOk: (pNext===grp), 
                e: eNext, 
                eOk: (eNext===grp), 
                s: sNext, 
                sOk: (sNext===grp) 
            });
            
            if(stage === 10) { 
                roll++; 
                stage = 1; 
            } else { 
                stage++; 
            }
            
            updatePredictions(); 
            renderTable(); 
            save();
        }

        function detectAndRecord(nextGrp) {
            // Get current history string
            const currentHistory = history.map(h => h.grp).join('');
            const hStr = currentHistory + nextGrp;
            
            console.log('Checking pattern for:', hStr);
            
            // Check for ALL patterns
            let patternFound = false;
            let currentLabel = "";
            let currentCount = 0;
            let currentCss = "";
            let patternType = "";
            
            // IMPORTANT: Check patterns in specific order
            
            // 1. First check for alternating patterns (SBSB or BSBS)
            // SBSBSB ·ÄÄ 6 chars ·ÄÜ·Ä≠·ÄØ·Äõ·ÄÑ·Ä∫ (SB)3 ·Äñ·Äº·ÄÖ·Ä∫·Äô·Äö·Ä∫
            const altMatch = hStr.match(/((SB){3,}|(BS){3,})$/);
            if (altMatch) {
                patternFound = true;
                patternType = "alternating";
                currentLabel = "·Äê·ÄÖ·Ä∫·ÄÅ·ÄØ·ÄÄ·Äª·Ä±·Ä¨·Ä∫·ÄÖ·ÄÆ Pattern";
                currentCount = altMatch[0].length;
                currentCss = "bg-jump border-purple-500";
                console.log('Alternating pattern detected:', altMatch[0], 'length:', currentCount);
            }
            
            // 2. Check for Big Streak (B ·ÄÜ·ÄÄ·Ä∫)
            if (!patternFound) {
                const bigStreak = hStr.match(/(B{4,})$/);
                if (bigStreak) {
                    patternFound = true;
                    patternType = "big_streak";
                    currentLabel = "·Ä°·ÄÄ·Äº·ÄÆ·Ä∏·Äê·Ä±·Ä¨·ÄÄ·Ä∫·Äú·Äª·Äæ·Ä±·Ä¨·ÄÄ·Ä∫";
                    currentCount = bigStreak[0].length;
                    currentCss = "bg-big border-red-500";
                    console.log('Big streak detected:', bigStreak[0]);
                }
            }
            
            // 3. Check for Small Streak (S ·ÄÜ·ÄÄ·Ä∫)
            if (!patternFound) {
                const smallStreak = hStr.match(/(S{4,})$/);
                if (smallStreak) {
                    patternFound = true;
                    patternType = "small_streak";
                    currentLabel = "·Ä°·Äû·Ä±·Ä∏·Äê·Ä±·Ä¨·ÄÄ·Ä∫·Äú·Äª·Äæ·Ä±·Ä¨·ÄÄ·Ä∫";
                    currentCount = smallStreak[0].length;
                    currentCss = "bg-small border-green-500";
                    console.log('Small streak detected:', smallStreak[0]);
                }
            }
            
            // 4. Check for BBSS Pattern
            if (!patternFound) {
                const bbssPattern = hStr.match(/((BBSS){2,}|(SSBB){2,})$/);
                if (bbssPattern) {
                    patternFound = true;
                    patternType = "bbss";
                    currentLabel = "BBSS Pattern";
                    currentCount = bbssPattern[0].length;
                    currentCss = "bg-double";
                    console.log('BBSS pattern detected:', bbssPattern[0]);
                }
            }
            
            // Get warning box element
            const warnBox = document.getElementById('streak-warning');
            
            if (patternFound) {
                console.log('Pattern FOUND:', currentLabel, 'count:', currentCount);
                
                // Check if this is a continuation of existing pattern
                if (activePattern) {
                    // Check if pattern is broken
                    const isSamePattern = activePattern.type === patternType;
                    
                    if (isSamePattern) {
                        // Continue same pattern - update count
                        activePattern.count = currentCount;
                        activePattern.label = currentLabel;
                        console.log('Continuing pattern, updated count to:', currentCount);
                    } else {
                        // Different pattern started - end old one, start new
                        console.log('Different pattern detected, ending old pattern:', activePattern.label);
                        savePatternToIntel(activePattern);
                        activePattern = {
                            type: patternType,
                            label: currentLabel,
                            count: currentCount,
                            css: currentCss
                        };
                    }
                } else {
                    // No active pattern - start new one
                    console.log('Starting NEW pattern:', currentLabel);
                    activePattern = {
                        type: patternType,
                        label: currentLabel,
                        count: currentCount,
                        css: currentCss
                    };
                }
                
                // Show warning box
                showWarning(currentLabel, currentCount, currentCss);
                
            } else {
                console.log('NO pattern detected');
                
                // Check if we just broke a pattern
                if (activePattern) {
                    console.log('Pattern BROKEN. Was:', activePattern.label);
                    
                    // Save the completed pattern
                    savePatternToIntel(activePattern);
                    
                    // Clear active pattern
                    activePattern = null;
                    
                    // Hide warning box
                    hideWarning();
                } else {
                    // No pattern was active, ensure warning is hidden
                    if (!warnBox.classList.contains('hidden')) {
                        console.log('No active pattern, hiding warning');
                        hideWarning();
                    }
                }
            }
            
            console.log('Active pattern after detection:', activePattern);
        }

        function showWarning(label, count, cssClass) {
            const warnBox = document.getElementById('streak-warning');
            const warningText = document.getElementById('warning-text');
            const warningBox = document.getElementById('warning-box');
            
            console.log('Showing warning:', label, count);
            
            warningText.textContent = `${label} - ${count} ·ÄÄ·Äº·Ä≠·Äô·Ä∫`;
            warningBox.className = `p-4 rounded-2xl text-center border-l-8 ${cssClass} shadow-2xl mx-2 animate-pulse`;
            
            // Remove hidden class to show
            warnBox.classList.remove('hidden');
            
            // Force display block
            setTimeout(() => {
                warnBox.style.display = 'block';
                warnBox.style.opacity = '1';
                warnBox.style.maxHeight = '100px';
            }, 10);
        }

        function hideWarning() {
            const warnBox = document.getElementById('streak-warning');
            
            console.log('Hiding warning box');
            
            // Add hidden class
            warnBox.classList.add('hidden');
            
            // Set styles to hide
            setTimeout(() => {
                warnBox.style.opacity = '0';
                warnBox.style.maxHeight = '0';
                warnBox.style.margin = '0';
                warnBox.style.padding = '0';
                
                // Completely hide after transition
                setTimeout(() => {
                    warnBox.style.display = 'none';
                }, 300);
            }, 10);
        }

        function savePatternToIntel(pattern) {
            if (pattern && pattern.count >= 4) {
                console.log('Saving pattern to intel:', pattern.label, pattern.count);
                
                intelLogs.unshift({
                    id: intelLogs.length + 1,
                    label: pattern.label,
                    count: pattern.count,
                    css: pattern.css,
                    time: `R${roll} S${stage}`
                });
                
                renderIntel();
            }
        }

        function updatePredictions() {
            if (!history.length) return;
            
            const last = history[history.length-1].val;
            
            // P-Logic: Even/Odd
            pNext = (last % 2 === 0) ? 'S' : 'B';
            
            // E-Logic: Sum of last 3
            eNext = history.length >= 3 ? 
                (history.slice(-3).reduce((a,b)=>a+b.val,0) % 2 === 0 ? 'S' : 'B') : "-";
            
            // S-Logic: Digital root of last 5
            if (history.length >= 5) {
                let sum = history.slice(-5).reduce((a,b)=>a+b.val,0);
                while(sum >= 10) {
                    sum = sum.toString().split('').map(Number).reduce((a,b)=>a+b,0);
                }
                sNext = (sum % 2 !== 0) ? 'B' : 'S';
            } else {
                sNext = "-";
            }
            
            document.getElementById('pred-p').innerText = pNext;
            document.getElementById('pred-e').innerText = eNext;
            document.getElementById('pred-s').innerText = sNext;
        }

        function renderIntel() {
            const container = document.getElementById('intel-log-container');
            const noIntel = document.getElementById('no-intel');
            
            if (intelLogs.length === 0) {
                noIntel.style.display = 'block';
                container.innerHTML = '';
            } else {
                noIntel.style.display = 'none';
                container.innerHTML = intelLogs.map(l => `
                    <div class="log-box ${l.css} shadow-lg border border-white/5 mb-2">
                        <div class="flex justify-between items-center">
                            <div class="flex items-center gap-3">
                                <span class="bg-black/30 w-8 h-8 flex items-center justify-center rounded-full text-[10px] font-black italic">#${l.id}</span>
                                <div>
                                    <p class="text-[11px] font-black italic uppercase">${l.label}</p>
                                    <p class="text-[12px] font-black underline">${l.count} ·ÄÄ·Äº·Ä≠·Äô·Ä∫ ·ÄÄ·Äª·ÄÅ·Ä≤·Ä∑·Äû·Ää·Ä∫</p>
                                </div>
                            </div>
                            <span class="text-[8px] font-black opacity-60">${l.time}</span>
                        </div>
                    </div>
                `).join('');
            }
        }

        function renderTable() {
            const container = document.getElementById('history-container');
            const rolls = history.reduce((acc, cur) => {
                if(!acc[cur.roll]) acc[cur.roll] = [];
                acc[cur.roll].push(cur);
                return acc;
            }, {});
            
            container.innerHTML = Object.keys(rolls).map(r => `
                <div class="flex-shrink-0 w-72 bg-white/5 p-4 rounded-[2.5rem] border border-white/5">
                    <div class="text-[11px] text-center font-black text-cyan-500 mb-3 border-b border-white/10 pb-2">Roll ${r}</div>
                    ${rolls[r].map(i => `
                        <div class="flex items-center justify-between py-2 border-b border-white/5 last:border-0">
                            <span class="text-[9px] text-gray-500 font-bold">${i.stage}</span>
                            <div class="flex flex-col items-center gap-0.5">
                                <div class="mini-shape border-red-500 text-red-500 rounded-full">${i.p}</div>
                                <span class="text-[8px] font-black ${i.pOk?'text-green-500':'text-red-500'}">${i.pOk?'‚úÖ':'‚ùå'}</span>
                            </div>
                            <div class="flex flex-col items-center gap-0.5">
                                <div class="mini-shape border-purple-500 text-purple-500 rounded-md">${i.e}</div>
                                <span class="text-[8px] font-black ${i.eOk?'text-green-500':'text-red-500'}">${i.eOk?'‚úÖ':'‚ùå'}</span>
                            </div>
                            <div class="flex flex-col items-center gap-0.5">
                                <div class="mini-shape border-green-500 text-green-500 rotate-45">
                                    <span class="-rotate-45 block">${i.s}</span>
                                </div>
                                <span class="text-[8px] font-black ${i.sOk?'text-green-500':'text-red-500'}">${i.sOk?'‚úÖ':'‚ùå'}</span>
                            </div>
                            <div class="g-num shadow-lg">${i.val}</div>
                        </div>
                    `).join('')}
                </div>
            `).join('');
            
            container.scrollLeft = container.scrollWidth;
        }

        function copyAnalysis() {
            let log = "OMNI SYSTEM RECORD\n------------------\n";
            history.forEach(h => {
                log += `N:${h.val} | P:${h.p}${h.pOk?'‚úÖ':'‚ùå'} | E:${h.e}${h.eOk?'‚úÖ':'‚ùå'} | S:${h.s}${h.sOk?'‚úÖ':'‚ùå'}\n`;
            });
            
            const ta = document.createElement("textarea");
            ta.value = log;
            document.body.appendChild(ta);
            ta.select();
            document.execCommand("copy");
            document.body.removeChild(ta);
            
            const t = document.getElementById('toast');
            t.style.display = 'block';
            setTimeout(() => {
                t.style.display = 'none';
            }, 2000);
        }

        function save() {
            localStorage.setItem('OMNI_V21_STABLE', JSON.stringify({
                history, 
                roll, 
                stage, 
                intelLogs,
                activePattern
            }));
        }

        function load() {
            const data = JSON.parse(localStorage.getItem('OMNI_V21_STABLE'));
            if(data) {
                history = data.history || [];
                roll = data.roll || 1;
                stage = data.stage || 1;
                intelLogs = data.intelLogs || [];
                activePattern = data.activePattern || null;
                
                renderTable();
                renderIntel();
                updatePredictions();
                
                // Restore warning box if active pattern exists
                const warnBox = document.getElementById('streak-warning');
                if (activePattern && activePattern.count >= 4) {
                    console.log('Restoring active pattern:', activePattern);
                    showWarning(
                        activePattern.label, 
                        activePattern.count, 
                        activePattern.css
                    );
                } else {
                    console.log('No active pattern to restore, hiding warning');
                    hideWarning();
                }
            }
            
            // Always focus input
            inputEl.focus();
        }

        function fullReset() {
            if(confirm("Clear all data? This cannot be undone.")) {
                localStorage.clear();
                location.reload();
            }
        }

        // Initialize on load
        window.addEventListener('DOMContentLoaded', load);
        
        // Debug function to test specific sequence
        window.testSequence = function(sequence) {
            console.log('Testing sequence:', sequence);
            const nums = sequence.split('').map(char => {
                if (char === 'S') return Math.floor(Math.random() * 4) + 1;
                if (char === 'B') return Math.floor(Math.random() * 5) + 5;
                return 0;
            });
            
            console.log('Numbers:', nums);
            
            // Simulate entering numbers
            nums.forEach((num, i) => {
                setTimeout(() => {
                    inputEl.value = num;
                    handleManualSubmit();
                }, i * 100);
            });
        };
    </script>
</body>
</html>
